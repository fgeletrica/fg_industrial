import 'dart:typed_data';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:csv/csv.dart';

import '../supabase_service.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:pdf/pdf.dart';

class HistoryPdfCsvScreen extends StatefulWidget {
  const HistoryPdfCsvScreen({super.key});

  @override
  State<HistoryPdfCsvScreen> createState() => _HistoryPdfCsvScreenState();
}

class _HistoryPdfCsvScreenState extends State<HistoryPdfCsvScreen> {
  DateTime from = DateTime.now();
  DateTime to = DateTime.now();

  bool loading = false;
  List<Map<String, dynamic>> rows = [];

  String shift = "ALL";

  List<Map<String, dynamic>> lines = [];
  List<Map<String, dynamic>> groups = [];
  List<Map<String, dynamic>> machines = [];
  String? lineId;
  String? groupId;
  String? machineId;

  @override
  void initState() {
    super.initState();
    _loadRefs();
  }

  Future<void> _loadRefs() async {
    try {
      final me = await Sb.c.from("profiles").select("site_id").eq("user_id", Sb.c.auth.currentUser!.id).maybeSingle();
      final siteId = me?["site_id"]?.toString();
      if (siteId == null) return;

      final l = await Sb.c.from("lines").select("id, name").eq("site_id", siteId).order("name");
      lines = (l as List).cast<Map<String, dynamic>>();
      if (mounted) setState(() {});
    } catch (_) {}
  }

  Future<void> _loadGroups() async {
    if (lineId == null) return;
    final g = await Sb.c.from("machine_groups").select("id, name").eq("line_id", lineId!).order("name");
    groups = (g as List).cast<Map<String, dynamic>>();
    groupId = groups.isNotEmpty ? groups.first["id"].toString() : null;
    await _loadMachines();
  }

  Future<void> _loadMachines() async {
    if (groupId == null) return;
    final m = await Sb.c.from("machines").select("id, name").eq("group_id", groupId!).order("name");
    machines = (m as List).cast<Map<String, dynamic>>();
    machineId = machines.isNotEmpty ? machines.first["id"].toString() : null;
  }

  String _shiftToDb(String v) => (v == "Manhã") ? "Manha" : v;

  Future<void> _search() async {
    setState(() => loading = true);
    try {
      final fromIso = DateTime(from.year, from.month, from.day).toIso8601String();
      final toIso = DateTime(to.year, to.month, to.day, 23, 59, 59).toIso8601String();

      // IMPORTANTE:
      // aplica filtros antes do order() pra manter PostgrestFilterBuilder
      var q = Sb.c
          .from("v_diagnostics_pdf")
          .select("id, site_code, line_name, group_name, machine_name, shift, problem, action_taken, root_cause, created_at")
          .gte("created_at", fromIso)
          .lte("created_at", toIso);

      if (shift != "ALL") {
        q = q.eq("shift", _shiftToDb(shift));
      }

      if (lineId != null) {
        final ln = lines.firstWhere((e) => e["id"].toString() == lineId, orElse: () => {});
        if (ln.isNotEmpty) q = q.eq("line_name", ln["name"].toString());
      }

      if (groupId != null) {
        final gn = groups.firstWhere((e) => e["id"].toString() == groupId, orElse: () => {});
        if (gn.isNotEmpty) q = q.eq("group_name", gn["name"].toString());
      }

      if (machineId != null) {
        final mn = machines.firstWhere((e) => e["id"].toString() == machineId, orElse: () => {});
        if (mn.isNotEmpty) q = q.eq("machine_name", mn["name"].toString());
      }

      final data = await q.order("created_at", ascending: false);
      rows = (data as List).cast<Map<String, dynamic>>();
      if (mounted) setState(() {});
    } catch (e) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Erro ao buscar: $e")));
    } finally {
      if (mounted) setState(() => loading = false);
    }
  }

  Future<Uint8List> _buildPdf() async {
  final doc = pw.Document();

  // Logo (asset)
  final logoBytes = (await rootBundle.load('assets/brand/coca_cola_andina.png')).buffer.asUint8List();
  final logo = pw.MemoryImage(logoBytes);

  final df = DateFormat("dd/MM/yyyy HH:mm");
  final dShort = DateFormat("dd/MM/yyyy");

  // Paleta “Coca-Cola”
  final ccRed = PdfColor.fromInt(0xFFE41E2B);   // vermelho forte
  final softGray = PdfColor.fromInt(0xFFF3F4F6); // cinza bem claro
  final textGray = PdfColor.fromInt(0xFF111827); // quase preto

  String turnoLabel() => shift == "ALL" ? "Todos" : shift;

  String getNameById(List<Map<String, dynamic>> list, String? id) {
    if (id == null) return "Todos";
    final found = list.firstWhere((e) => e["id"].toString() == id, orElse: () => {});
    return (found["name"] ?? "Todos").toString();
  }

  final linha = getNameById(lines, lineId);
  final grupo = getNameById(groups, groupId);
  final maquina = getNameById(machines, machineId);

  doc.addPage(
    pw.MultiPage(
      pageFormat: PdfPageFormat.a4,
      margin: const pw.EdgeInsets.fromLTRB(28, 24, 28, 28),

      header: (ctx) {
        return pw.Column(
          children: [
            pw.Row(
              crossAxisAlignment: pw.CrossAxisAlignment.center,
              children: [
                pw.Container(
                  width: 90,
                  height: 40,
                  child: pw.Image(logo, fit: pw.BoxFit.contain),
                ),
                pw.SizedBox(width: 12),
                pw.Expanded(
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Text(
                        "Coca-Cola Andina • DQX",
                        style: pw.TextStyle(
                          fontSize: 14,
                          fontWeight: pw.FontWeight.bold,
                          color: textGray,
                        ),
                      ),
                      pw.Text(
                        "Relatório de Diagnósticos (Histórico)",
                        style: pw.TextStyle(
                          fontSize: 11,
                          color: PdfColor.fromInt(0xFF374151),
                        ),
                      ),
                    ],
                  ),
                ),
                pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.end,
                  children: [
                    pw.Text(
                      "Gerado em: ${df.format(DateTime.now())}",
                      style: pw.TextStyle(fontSize: 9, color: PdfColor.fromInt(0xFF6B7280)),
                    ),
                    pw.Text(
                      "Página ${ctx.pageNumber} / ${ctx.pagesCount}",
                      style: pw.TextStyle(fontSize: 9, color: PdfColor.fromInt(0xFF6B7280)),
                    ),
                  ],
                )
              ],
            ),
            pw.SizedBox(height: 10),
            pw.Container(height: 2, color: ccRed),
            pw.SizedBox(height: 12),

            pw.Container(
              decoration: pw.BoxDecoration(
                color: softGray,
                borderRadius: pw.BorderRadius.circular(8),
              ),
              padding: const pw.EdgeInsets.all(10),
              child: pw.Row(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Expanded(
                    child: pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text("Período", style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold, color: PdfColor.fromInt(0xFF374151))),
                        pw.Text("${dShort.format(from)} até ${dShort.format(to)}", style: pw.TextStyle(fontSize: 10, color: textGray)),
                      ],
                    ),
                  ),
                  pw.Expanded(
                    child: pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text("Turno", style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold, color: PdfColor.fromInt(0xFF374151))),
                        pw.Text(turnoLabel(), style: pw.TextStyle(fontSize: 10, color: textGray)),
                      ],
                    ),
                  ),
                  pw.Expanded(
                    child: pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text("Linha / Grupo / Máquina", style: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold, color: PdfColor.fromInt(0xFF374151))),
                        pw.Text("$linha • $grupo • $maquina", style: pw.TextStyle(fontSize: 10, color: textGray)),
                      ],
                    ),
                  ),
                ],
              ),
            ),
            pw.SizedBox(height: 10),
          ],
        );
      },

      footer: (ctx) {
        return pw.Column(
          children: [
            pw.SizedBox(height: 8),
            pw.Container(height: 1, color: PdfColor.fromInt(0xFFE5E7EB)),
            pw.SizedBox(height: 6),
            pw.Row(
              children: [
                pw.Text(
                  "FG Industrial • Relatório interno • DQX",
                  style: pw.TextStyle(fontSize: 8, color: PdfColor.fromInt(0xFF6B7280)),
                ),
                pw.Spacer(),
                pw.Text(
                  "Página ${ctx.pageNumber}/${ctx.pagesCount}",
                  style: pw.TextStyle(fontSize: 8, color: PdfColor.fromInt(0xFF6B7280)),
                ),
              ],
            ),
          ],
        );
      },

      build: (ctx) {
        if (rows.isEmpty) {
          return [
            pw.SizedBox(height: 24),
            pw.Text("Sem registros no período/filtro selecionado.", style: pw.TextStyle(fontSize: 12, color: textGray)),
          ];
        }

        final data = rows.map((r) {
          final created = DateTime.tryParse(r["created_at"].toString());
          return [
            created == null ? "" : df.format(created),
            (r["line_name"] ?? "").toString(),
            (r["group_name"] ?? "").toString(),
            (r["machine_name"] ?? "").toString(),
            (r["shift"] ?? "").toString(),
            (r["problem"] ?? "").toString(),
            (r["action_taken"] ?? "").toString(),
            (r["root_cause"] == true) ? "SIM" : "NÃO",
          ];
        }).toList();

        return [
          pw.Text(
            "Resultados: ${rows.length}",
            style: pw.TextStyle(fontSize: 11, fontWeight: pw.FontWeight.bold, color: textGray),
          ),
          pw.SizedBox(height: 10),

          pw.Table.fromTextArray(
            headers: const ["Data", "Linha", "Grupo", "Máquina", "Turno", "Problema", "Ação", "Causa raiz"],
            data: data,

            headerStyle: pw.TextStyle(fontSize: 9, fontWeight: pw.FontWeight.bold, color: PdfColors.white),
            headerDecoration: pw.BoxDecoration(color: ccRed),

            cellStyle: pw.TextStyle(fontSize: 8, color: textGray),
            cellAlignment: pw.Alignment.centerLeft,

            rowDecoration: const pw.BoxDecoration(),
            oddRowDecoration: pw.BoxDecoration(color: PdfColor.fromInt(0xFFF9FAFB)),

            border: pw.TableBorder.all(color: PdfColor.fromInt(0xFFE5E7EB), width: 0.6),
            cellPadding: const pw.EdgeInsets.symmetric(vertical: 5, horizontal: 6),

            columnWidths: {
              0: const pw.FlexColumnWidth(1.2),
              1: const pw.FlexColumnWidth(1.0),
              2: const pw.FlexColumnWidth(1.0),
              3: const pw.FlexColumnWidth(1.1),
              4: const pw.FlexColumnWidth(0.7),
              5: const pw.FlexColumnWidth(2.2),
              6: const pw.FlexColumnWidth(2.2),
              7: const pw.FlexColumnWidth(0.7),
            },
          ),
        ];
      },
    ),
  );

  return doc.save();
}


  Future<void> _saveAndOpenPdf() async {
    final bytes = await _buildPdf();

    final home = Platform.environment["HOME"] ?? ".";
    final downloads = Directory("$home/Downloads");
    if (!downloads.existsSync()) {
      downloads.createSync(recursive: true);
    }

    final ts = DateFormat("yyyyMMdd_HHmm").format(DateTime.now());
    final filePath = "${downloads.path}/FG_Industrial_Historico_${ts}.pdf";

    final f = File(filePath);
    await f.writeAsBytes(bytes, flush: true);

    try {
      await Process.run("xdg-open", [filePath]);
    } catch (_) {}
  }
String _buildCsv() {
    final df = DateFormat("yyyy-MM-dd HH:mm");
    final data = <List<String>>[
      ["id", "created_at", "site", "line", "group", "machine", "shift", "problem", "action_taken", "root_cause"],
      ...rows.map((r) {
        final created = DateTime.tryParse(r["created_at"].toString());
        return [
          (r["id"] ?? "").toString(),
          created == null ? "" : df.format(created),
          (r["site_code"] ?? "").toString(),
          (r["line_name"] ?? "").toString(),
          (r["group_name"] ?? "").toString(),
          (r["machine_name"] ?? "").toString(),
          (r["shift"] ?? "").toString(),
          (r["problem"] ?? "").toString(),
          (r["action_taken"] ?? "").toString(),
          (r["root_cause"] == true) ? "true" : "false",
        ];
      }),
    ];
    return const ListToCsvConverter().convert(data);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Histórico • PDF/CSV")),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          Row(
            children: [
              Expanded(child: _dateField("De", from, (d) => setState(() => from = d))),
              const SizedBox(width: 10),
              Expanded(child: _dateField("Até", to, (d) => setState(() => to = d))),
            ],
          ),
          const SizedBox(height: 10),
          DropdownButtonFormField<String>(
            value: shift,
            decoration: const InputDecoration(labelText: "Turno"),
            items: const [
              DropdownMenuItem(value: "ALL", child: Text("ALL")),
              DropdownMenuItem(value: "Manhã", child: Text("Manhã")),
              DropdownMenuItem(value: "Tarde", child: Text("Tarde")),
              DropdownMenuItem(value: "Noite", child: Text("Noite")),
              DropdownMenuItem(value: "Indefinido", child: Text("Indefinido")),
            ],
            onChanged: (v) => setState(() => shift = v ?? "ALL"),
          ),
          const SizedBox(height: 10),
          _dropMaps(
            label: "Linha",
            value: lineId,
            items: lines,
            getLabel: (x) => x["name"].toString(),
            onChanged: (v) async {
              setState(() {
                lineId = v;
                groups = [];
                machines = [];
                groupId = null;
                machineId = null;
              });
              await _loadGroups();
              if (mounted) setState(() {});
            },
          ),
          const SizedBox(height: 10),
          _dropMaps(
            label: "Máquinas (grupo)",
            value: groupId,
            items: groups,
            getLabel: (x) => x["name"].toString(),
            onChanged: (v) async {
              setState(() {
                groupId = v;
                machines = [];
                machineId = null;
              });
              await _loadMachines();
              if (mounted) setState(() {});
            },
          ),
          const SizedBox(height: 10),
          _dropMaps(
            label: "Máquina (item)",
            value: machineId,
            items: machines,
            getLabel: (x) => x["name"].toString(),
            onChanged: (v) => setState(() => machineId = v),
          ),
          const SizedBox(height: 12),
          SizedBox(
            height: 48,
            child: ElevatedButton.icon(
              onPressed: loading ? null : _search,
              icon: const Icon(Icons.search),
              label: Text(loading ? "Buscando..." : "Buscar"),
            ),
          ),
          const SizedBox(height: 12),
          Text("Resultados: ${rows.length}", style: const TextStyle(fontWeight: FontWeight.w800)),
          const SizedBox(height: 10),
          Row(
            children: [
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: rows.isEmpty ? null : () async { await _saveAndOpenPdf(); },
                  icon: const Icon(Icons.picture_as_pdf),
                  label: const Text("Gerar PDF"),
                ),
              ),
              const SizedBox(width: 10),
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: rows.isEmpty
                      ? null
                      : () async {
                          final csv = _buildCsv();
                          if (!mounted) return;
                          showDialog(
                            context: context,
                            builder: (_) => AlertDialog(
                              title: const Text("CSV (copiar)"),
                              content: SizedBox(
                                width: 600,
                                child: SingleChildScrollView(child: SelectableText(csv)),
                              ),
                              actions: [
                                TextButton(onPressed: () => Navigator.pop(context), child: const Text("Fechar")),
                              ],
                            ),
                          );
                        },
                  icon: const Icon(Icons.table_view),
                  label: const Text("Gerar CSV"),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _dateField(String label, DateTime value, ValueChanged<DateTime> onPick) {
    return InkWell(
      onTap: () async {
        final d = await showDatePicker(
          context: context,
          firstDate: DateTime(2020),
          lastDate: DateTime(2100),
          initialDate: value,
        );
        if (d != null) onPick(d);
      },
      child: InputDecorator(
        decoration: InputDecoration(labelText: label),
        child: Text(DateFormat("dd/MM/yyyy").format(value)),
      ),
    );
  }

  Widget _dropMaps({
    required String label,
    required String? value,
    required List<Map<String, dynamic>> items,
    required String Function(Map<String, dynamic>) getLabel,
    required ValueChanged<String?> onChanged,
  }) {
    return DropdownButtonFormField<String>(
      value: value,
      decoration: InputDecoration(labelText: label),
      items: items.map((e) => DropdownMenuItem(value: e["id"].toString(), child: Text(getLabel(e)))).toList(),
      onChanged: items.isEmpty ? null : onChanged,
    );
  }
}
